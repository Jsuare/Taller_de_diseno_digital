`timescale 1ns/1ps   // Unidad/precisión de tiempos para simulación: 1 ns / 1 ps

module register_file #(
  parameter int W = 8,  // Ancho de palabra (bits por registro)
  parameter int N = 3   // Bits de dirección (cantidad de registros = 2^N)
)(
  input  logic                 clk,       // Reloj
  input  logic                 rst,       // Reset síncrono (activo en 1)
  input  logic                 we,        // Habilitador de escritura
  input  logic [N-1:0]         addr_rd,   // Dirección de escritura
  input  logic [W-1:0]         data_in,   // Dato a escribir
  input  logic [N-1:0]         addr_rs1,  // Dirección de lectura para puerto 1
  input  logic [N-1:0]         addr_rs2,  // Dirección de lectura para puerto 2
  output logic [W-1:0]         rs1,       // Salida de lectura puerto 1
  output logic [W-1:0]         rs2        // Salida de lectura puerto 2
);

  localparam int DEPTH = 1 << N;          // Cantidad de registros = 2^N
  logic [W-1:0] mem [0:DEPTH-1];          // Memoria: arreglo de DEPTH registros de W bits

  // Bloque secuencial: escritura y reset
  always_ff @(posedge clk) begin
    if (rst) begin
      // Reset sincrónico: limpia todos los registros a 0
      for (int i = 0; i < DEPTH; i++) mem[i] <= '0;
    end else if (we && (addr_rd != '0)) begin
      // Escritura en flanco positivo si we=1 y NO es el registro 0
      // (el registro 0 queda de solo lectura en 0)
      mem[addr_rd] <= data_in;
    end
  end

  // Bloque combinacional: lecturas asíncronas
  always_comb begin
    // Si la dirección de lectura es 0, fuerza 0 (R0 siempre 0).
    // En caso contrario, entrega el contenido del registro direccionado.
    rs1 = (addr_rs1 == '0) ? '0 : mem[addr_rs1];
    rs2 = (addr_rs2 == '0) ? '0 : mem[addr_rs2];
  end

endmodule

